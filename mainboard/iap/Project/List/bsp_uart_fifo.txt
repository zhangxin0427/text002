; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\bsp_uart_fifo.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\User -I..\User\bsp\inc -I..\User\bsp -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\MALLOC -I..\FatFs\src -I..\FatFs\src\option -I..\Iap -I"E:\Program Files\MDK 4.74\ARM\RV31\INC" -I"E:\Program Files\MDK 4.74\ARM\CMSIS\Include" -I"E:\Program Files\MDK 4.74\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\bsp_uart_fifo.crf ..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;140    */
;;;141    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;142    {
;;;143    	NVIC_InitTypeDef NVIC_InitStructure;
;;;144    
;;;145    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;146    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000008  2001              MOVS     r0,#1
00000a  f88d0001          STRB     r0,[sp,#1]
;;;147    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;148    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;149    	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;150    
;;;151    }
000020  bd08              POP      {r3,pc}
;;;152    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;88     */
;;;89     static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;90     {
000002  b085              SUB      sp,sp,#0x14
;;;91     	GPIO_InitTypeDef GPIO_InitStructure;
;;;92     	USART_InitTypeDef USART_InitStructure;
;;;93     
;;;94     
;;;95     		/* 第1步：打开GPIO和USART部件的时钟 */
;;;96     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;97     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;98     	USART_DeInit(USART1);					  	//复位USART1
000014  4825              LDR      r0,|L2.172|
000016  f7fffffe          BL       USART_DeInit
;;;99     	
;;;100    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;101    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00001a  f44f7000          MOV      r0,#0x200
00001e  f8ad0010          STRH     r0,[sp,#0x10]
;;;102    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0013          STRB     r0,[sp,#0x13]
;;;103    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000028  2003              MOVS     r0,#3
00002a  f88d0012          STRB     r0,[sp,#0x12]
;;;104    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002e  a904              ADD      r1,sp,#0x10
000030  481f              LDR      r0,|L2.176|
000032  f7fffffe          BL       GPIO_Init
;;;105    
;;;106    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;107    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;108    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;109    	*/
;;;110    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000036  f44f6080          MOV      r0,#0x400
00003a  f8ad0010          STRH     r0,[sp,#0x10]
;;;111    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003e  2004              MOVS     r0,#4
000040  f88d0013          STRB     r0,[sp,#0x13]
;;;112    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  a904              ADD      r1,sp,#0x10
000046  481a              LDR      r0,|L2.176|
000048  f7fffffe          BL       GPIO_Init
;;;113    	
;;;114    	/* 第4步： 配置串口硬件参数 */
;;;115    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
00004c  f44f30e1          MOV      r0,#0x1c200
000050  9000              STR      r0,[sp,#0]
;;;116    	USART_InitStructure.USART_WordLength = USART_WordLength_9b;
000052  f44f5080          MOV      r0,#0x1000
000056  f8ad0004          STRH     r0,[sp,#4]
;;;117    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00005a  2000              MOVS     r0,#0
00005c  f8ad0006          STRH     r0,[sp,#6]
;;;118    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000060  f8ad0008          STRH     r0,[sp,#8]
;;;119    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000064  f8ad000c          STRH     r0,[sp,#0xc]
;;;120    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000068  200c              MOVS     r0,#0xc
00006a  f8ad000a          STRH     r0,[sp,#0xa]
;;;121    	USART_Init(USART1, &USART_InitStructure);
00006e  4669              MOV      r1,sp
000070  480e              LDR      r0,|L2.172|
000072  f7fffffe          BL       USART_Init
;;;122    
;;;123    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000076  2201              MOVS     r2,#1
000078  f2405125          MOV      r1,#0x525
00007c  480b              LDR      r0,|L2.172|
00007e  f7fffffe          BL       USART_ITConfig
;;;124    
;;;125    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000082  2101              MOVS     r1,#1
000084  4809              LDR      r0,|L2.172|
000086  f7fffffe          BL       USART_Cmd
;;;126    	USART_GetFlagStatus(USART1, USART_FLAG_TC);		//解决第一个字节无法发送的问题，详情看官方RM0033文档的TC跟TXE 标志位
00008a  2140              MOVS     r1,#0x40
00008c  4807              LDR      r0,|L2.172|
00008e  f7fffffe          BL       USART_GetFlagStatus
;;;127    	USART1_DMA_Config(DMA1_Channel4,(u32)&USART1->DR,(u32)TXDBUF);
000092  4a08              LDR      r2,|L2.180|
000094  4905              LDR      r1,|L2.172|
000096  1d09              ADDS     r1,r1,#4
000098  4807              LDR      r0,|L2.184|
00009a  f7fffffe          BL       USART1_DMA_Config
;;;128    	USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);
00009e  2201              MOVS     r2,#1
0000a0  2180              MOVS     r1,#0x80
0000a2  4802              LDR      r0,|L2.172|
0000a4  f7fffffe          BL       USART_DMACmd
;;;129    
;;;130    
;;;131    }
0000a8  b005              ADD      sp,sp,#0x14
0000aa  bd00              POP      {pc}
;;;132    
                          ENDP

                  |L2.172|
                          DCD      0x40013800
                  |L2.176|
                          DCD      0x40010800
                  |L2.180|
                          DCD      TXDBUF
                  |L2.184|
                          DCD      0x40020044

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;38     */
;;;39     void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;40     {
;;;41     	GPIO_InitTypeDef GPIO_InitStructure;
;;;42     	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;43     
;;;44     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;45     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;46     	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  01c0              LSLS     r0,r0,#7
000018  f8ad0000          STRH     r0,[sp,#0]
;;;47     	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L3.40|
000020  f7fffffe          BL       GPIO_Init
;;;48     }
000024  bd08              POP      {r3,pc}
;;;49     
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40010800

                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;58     */
;;;59     void RS485_SendBefor(void)
000000  f44f6000          MOV      r0,#0x800
;;;60     {
;;;61     	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000004  4901              LDR      r1,|L4.12|
000006  6008              STR      r0,[r1,#0]
;;;62     }
000008  4770              BX       lr
;;;63     
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40010810

                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;72     */
;;;73     void RS485_SendOver(void)
000000  f44f6000          MOV      r0,#0x800
;;;74     {
;;;75     	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000004  4901              LDR      r1,|L5.12|
000006  6008              STR      r0,[r1,#0]
;;;76     }
000008  4770              BX       lr
;;;77     
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40010814

                          AREA ||i.Send_Lamp_Cmd||, CODE, READONLY, ALIGN=2

                  Send_Lamp_Cmd PROC
;;;207    
;;;208    void Send_Lamp_Cmd(u16 length)
000000  b510              PUSH     {r4,lr}
;;;209    {
000002  4604              MOV      r4,r0
;;;210    			GPIOA->CRH &= 0xFFFFFF0F;				//配置PA9为推挽输出模式，输出Break信号
000004  481c              LDR      r0,|L6.120|
000006  6800              LDR      r0,[r0,#0]
000008  f02000f0          BIC      r0,r0,#0xf0
00000c  491a              LDR      r1,|L6.120|
00000e  6008              STR      r0,[r1,#0]
;;;211    			GPIOA->CRH |= 0x00000030;
000010  4608              MOV      r0,r1
000012  6800              LDR      r0,[r0,#0]
000014  f0400030          ORR      r0,r0,#0x30
000018  6008              STR      r0,[r1,#0]
;;;212    			GPIOA->BRR = GPIO_Pin_9;
00001a  1548              ASRS     r0,r1,#21
00001c  4916              LDR      r1,|L6.120|
00001e  3110              ADDS     r1,r1,#0x10
000020  6008              STR      r0,[r1,#0]
;;;213    			bsp_DelayUS(100);
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       bsp_DelayUS
;;;214    			GPIOA->BSRR = GPIO_Pin_9;
000028  f44f7000          MOV      r0,#0x200
00002c  4912              LDR      r1,|L6.120|
00002e  310c              ADDS     r1,r1,#0xc
000030  6008              STR      r0,[r1,#0]
;;;215    			bsp_DelayUS(5);
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       bsp_DelayUS
;;;216    			GPIOA->CRH &= 0xFFFFFF0F;				//恢复PA9为复用推挽输出模式
000038  480f              LDR      r0,|L6.120|
00003a  6800              LDR      r0,[r0,#0]
00003c  f02000f0          BIC      r0,r0,#0xf0
000040  490d              LDR      r1,|L6.120|
000042  6008              STR      r0,[r1,#0]
;;;217    			GPIOA->CRH |= 0x000000B0;
000044  4608              MOV      r0,r1
000046  6800              LDR      r0,[r0,#0]
000048  f04000b0          ORR      r0,r0,#0xb0
00004c  6008              STR      r0,[r1,#0]
;;;218    			bsp_DelayUS(5);
00004e  2005              MOVS     r0,#5
000050  f7fffffe          BL       bsp_DelayUS
;;;219    
;;;220    			USART_DMA_Enable(DMA1_Channel4,length);
000054  4621              MOV      r1,r4
000056  4809              LDR      r0,|L6.124|
000058  f7fffffe          BL       USART_DMA_Enable
;;;221    			bsp_DelayMS(5);
00005c  2005              MOVS     r0,#5
00005e  f7fffffe          BL       bsp_DelayMS
;;;222    	
;;;223    			while(DMA_GetFlagStatus(DMA1_FLAG_TC4) != SET);		//判断数据是否发送完毕
000062  bf00              NOP      
                  |L6.100|
000064  f44f5000          MOV      r0,#0x2000
000068  f7fffffe          BL       DMA_GetFlagStatus
00006c  2801              CMP      r0,#1
00006e  d1f9              BNE      |L6.100|
;;;224    			DMA_ClearFlag(DMA1_FLAG_TC4);				//清除标志位
000070  0340              LSLS     r0,r0,#13
000072  f7fffffe          BL       DMA_ClearFlag
;;;225    }
000076  bd10              POP      {r4,pc}
;;;226    
                          ENDP

                  |L6.120|
                          DCD      0x40010804
                  |L6.124|
                          DCD      0x40020044

                          AREA ||i.USART1_DMA_Config||, CODE, READONLY, ALIGN=1

                  USART1_DMA_Config PROC
;;;160    ********************************************/
;;;161    void USART1_DMA_Config(DMA_Channel_TypeDef*DMA_CHx,u32 cpar,u32 cmar)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  b08c              SUB      sp,sp,#0x30
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;163    	DMA_InitTypeDef DMA_InitStructure;
;;;164    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;165    	bsp_DelayUS(5);
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       bsp_DelayUS
;;;166    	DMA_DeInit(DMA_CHx);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       DMA_DeInit
;;;167    	DMA_InitStructure.DMA_PeripheralBaseAddr = cpar;				//设定外设地址
00001e  9401              STR      r4,[sp,#4]
;;;168    	DMA_InitStructure.DMA_MemoryBaseAddr = cmar;					//设定存储器地址
000020  9502              STR      r5,[sp,#8]
;;;169    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;				//数据传输方向从存储器到外设
000022  2010              MOVS     r0,#0x10
000024  9003              STR      r0,[sp,#0xc]
;;;170    	DMA_InitStructure.DMA_BufferSize = 64;						//DMA4通道缓存大小
000026  2040              MOVS     r0,#0x40
000028  9004              STR      r0,[sp,#0x10]
;;;171    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;		//外设地址不变
00002a  2000              MOVS     r0,#0
00002c  9005              STR      r0,[sp,#0x14]
;;;172    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				//存储器地址递增
00002e  2080              MOVS     r0,#0x80
000030  9006              STR      r0,[sp,#0x18]
;;;173    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; 	//外设数据宽度为HalfWord
000032  0040              LSLS     r0,r0,#1
000034  9007              STR      r0,[sp,#0x1c]
;;;174    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; 		//存储器数据宽度为HalfWord
000036  0080              LSLS     r0,r0,#2
000038  9008              STR      r0,[sp,#0x20]
;;;175    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;					//工作在正常缓存模式
00003a  2000              MOVS     r0,#0
00003c  9009              STR      r0,[sp,#0x24]
;;;176    	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;				//通道具有中优先级
00003e  f44f5080          MOV      r0,#0x1000
000042  900a              STR      r0,[sp,#0x28]
;;;177    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;					//非内存到内存模式
000044  2000              MOVS     r0,#0
000046  900b              STR      r0,[sp,#0x2c]
;;;178    	DMA_Init(DMA_CHx,&DMA_InitStructure);
000048  a901              ADD      r1,sp,#4
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       DMA_Init
;;;179    	
;;;180    }
000050  b00c              ADD      sp,sp,#0x30
000052  bd70              POP      {r4-r6,pc}
;;;181    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=1

                  USART1_IRQHandler PROC
;;;351    
;;;352    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;353    {
;;;354    	
;;;355    	Uart1IRQ();
000002  f7fffffe          BL       Uart1IRQ
;;;356    	
;;;357    }
000006  bd10              POP      {r4,pc}
;;;358    
                          ENDP


                          AREA ||i.USART_BufferSend||, CODE, READONLY, ALIGN=1

                  USART_BufferSend PROC
;;;237    */
;;;238    void USART_BufferSend(USART_TypeDef* USARTx, u8* pBuffer, u16 NumByteToSend)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;239    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;240    	u16 temp;
;;;241        while(NumByteToSend--)
00000a  e00c              B        |L9.38|
                  |L9.12|
;;;242        {
;;;243    //				RS485_SendBefor();							//发送前485设置为发送模式
;;;244    //			  bsp_DelayUS(1200);												//延时1.2ms
;;;245            temp = (u16)(*pBuffer)&0x1FF;	                              //一个字节，16bit，2B
00000c  7825              LDRB     r5,[r4,#0]
;;;246            USART_SendData(USARTx,temp);								  //选择发送端口
00000e  4629              MOV      r1,r5
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       USART_SendData
;;;247            while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);  //等待发送结束，结束后标志位清0
000016  bf00              NOP      
                  |L9.24|
000018  2140              MOVS     r1,#0x40
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       USART_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L9.24|
;;;248            pBuffer++;													  
000024  1c64              ADDS     r4,r4,#1
                  |L9.38|
000026  0030              MOVS     r0,r6                 ;241
000028  f1a60101          SUB      r1,r6,#1              ;241
00002c  b28e              UXTH     r6,r1                 ;241
00002e  d1ed              BNE      |L9.12|
;;;249        }
;;;250    //				RS485_SendOver();  											//发送完成需要把485设置为接收模式
;;;251    //		    bsp_DelayUS(1200);												//延时1.2ms
;;;252    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;253    
                          ENDP


                          AREA ||i.USART_BufferSend9Bit||, CODE, READONLY, ALIGN=1

                  USART_BufferSend9Bit PROC
;;;266    */
;;;267    void USART_BufferSend9Bit(USART_TypeDef* USARTx, u16* pBuffer, u16 NumByteToSend)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;268    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;269    	u16 temp;
;;;270        while(NumByteToSend--)
00000a  e00e              B        |L10.42|
                  |L10.12|
;;;271        {
;;;272    //				RS485_SendBefor();							//发送前485设置为发送模式
;;;273    //			  bsp_DelayUS(1200);												//延时1.2ms
;;;274            temp = (u16)(*pBuffer)&0x1FF;	                              //一个字节，16bit，2B
00000c  8820              LDRH     r0,[r4,#0]
00000e  f3c00608          UBFX     r6,r0,#0,#9
;;;275            USART_SendData(USARTx,temp);								  //选择发送端口
000012  4631              MOV      r1,r6
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       USART_SendData
;;;276            while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);  //等待发送结束，结束后标志位清0
00001a  bf00              NOP      
                  |L10.28|
00001c  2140              MOVS     r1,#0x40
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       USART_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L10.28|
;;;277            pBuffer++;													  
000028  1ca4              ADDS     r4,r4,#2
                  |L10.42|
00002a  0028              MOVS     r0,r5                 ;270
00002c  f1a50101          SUB      r1,r5,#1              ;270
000030  b28d              UXTH     r5,r1                 ;270
000032  d1eb              BNE      |L10.12|
;;;278        }
;;;279    //				RS485_SendOver();  											//发送完成需要把485设置为接收模式
;;;280    //		    bsp_DelayUS(1200);												//延时1.2ms
;;;281    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;282    
                          ENDP


                          AREA ||i.USART_DMA_Enable||, CODE, READONLY, ALIGN=1

                  USART_DMA_Enable PROC
;;;189    ********************************************/
;;;190    void USART_DMA_Enable(DMA_Channel_TypeDef*DMA_CHx,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;192    	DMA_Cmd(DMA_CHx,DISABLE);					//关闭DMA通道
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       DMA_Cmd
;;;193    	DMA_SetCurrDataCounter(DMA_CHx,len);				//配置数据传输量
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       DMA_SetCurrDataCounter
;;;194    	DMA_Cmd(DMA_CHx,ENABLE);					//开启DMA通道
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       DMA_Cmd
;;;195    }
00001e  bd70              POP      {r4-r6,pc}
;;;196    
                          ENDP


                          AREA ||i.USART_SendByte||, CODE, READONLY, ALIGN=1

                  USART_SendByte PROC
;;;292    */
;;;293    void USART_SendByte(USART_TypeDef* USARTx,u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;295    //   RS485_SendBefor();												//发送之前需要把485设置为发送模式
;;;296    //	 bsp_DelayUS(1200);												//延时1.2ms
;;;297       USART_SendData(USARTx,data);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_SendData
;;;298       while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);//等待发送结束，结束后标志位清0
00000e  bf00              NOP      
                  |L12.16|
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L12.16|
;;;299    //	 RS485_SendOver();  											//发送完成需要把485设置为接收模式
;;;300    //	 bsp_DelayUS(1200);												//延时1.2ms
;;;301    }
00001c  bd70              POP      {r4-r6,pc}
;;;302    
                          ENDP


                          AREA ||i.Uart1IRQ||, CODE, READONLY, ALIGN=2

                  Uart1IRQ PROC
;;;313    uint8_t getdataok=0;	//接收到数据标志位
;;;314    static void Uart1IRQ(void)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316    		
;;;317    	/* 处理接收中断  */
;;;318    	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  480e              LDR      r0,|L13.64|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1b8              CBZ      r0,|L13.62|
;;;319    	{
;;;320    		
;;;321    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;322    		uint8_t ch;
;;;323    		
;;;324    		USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);/*关闭通信*/
00000e  2200              MOVS     r2,#0
000010  f2405125          MOV      r1,#0x525
000014  480a              LDR      r0,|L13.64|
000016  f7fffffe          BL       USART_ITConfig
;;;325    		USART_ClearITPendingBit(USART1,USART_IT_RXNE);		  //清除标志
00001a  f2405125          MOV      r1,#0x525
00001e  4808              LDR      r0,|L13.64|
000020  f7fffffe          BL       USART_ClearITPendingBit
;;;326    		
;;;327    		ch = (u8)USART_ReceiveData(USART1);				  			//接收数据
000024  4806              LDR      r0,|L13.64|
000026  f7fffffe          BL       USART_ReceiveData
00002a  b2c4              UXTB     r4,r0
;;;328    		RXDBUF[0]=ch;
00002c  4805              LDR      r0,|L13.68|
00002e  8004              STRH     r4,[r0,#0]
;;;329    		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);/*打开通信*/
000030  2201              MOVS     r2,#1
000032  f2405125          MOV      r1,#0x525
000036  4802              LDR      r0,|L13.64|
000038  f7fffffe          BL       USART_ITConfig
;;;330    		
;;;331    //		if(RXDBUF[0]==0xfe)
;;;332    //		{
;;;333    //			getdataok=1;
;;;334    //		
;;;335    //		}
;;;336    		
;;;337    		
;;;338    
;;;339    	
;;;340    	}
00003c  bf00              NOP      
                  |L13.62|
;;;341    }
00003e  bd10              POP      {r4,pc}
;;;342    
                          ENDP

                  |L13.64|
                          DCD      0x40013800
                  |L13.68|
                          DCD      RXDBUF

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;15     */
;;;16     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;17     {
;;;18     
;;;19     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000002  f7fffffe          BL       InitHardUart
;;;20     
;;;21     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
000006  f7fffffe          BL       RS485_InitTXE
;;;22     
;;;23     	ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;24     	
;;;25     	RS485_SendBefor(); //初始化485设置为发送模式
00000e  f7fffffe          BL       RS485_SendBefor
;;;26     }
000012  bd10              POP      {r4,pc}
;;;27     
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;388    */
;;;389    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;390    {
000002  4604              MOV      r4,r0
;;;391    	/* 等待串口1输入数据 */
;;;392    	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
000004  bf00              NOP      
                  |L15.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L15.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L15.6|
;;;393    
;;;394    	return (int)USART_ReceiveData(USART1);
000012  4802              LDR      r0,|L15.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;395    
;;;396    }
000018  bd10              POP      {r4,pc}
;;;397    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;368    */
;;;369    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;371    
;;;372    	/* 写一个字节到USART1 */
;;;373    	USART_SendData(USART1, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L16.32|
00000a  f7fffffe          BL       USART_SendData
;;;374    	/* 等待发送结束 */
;;;375    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L16.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L16.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L16.16|
;;;376    	{}
;;;377    	return ch;
00001c  4620              MOV      r0,r4
;;;378    
;;;379    }
00001e  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP

                  |L16.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  RXDBUF
                          %        20
                  TXDBUF
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  countdata
000000  00                DCB      0x00
                  getdataok
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_RXDBUF____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_RXDBUF____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_RXDBUF____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_RXDBUF____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
