L 1 "..\FATFS\src\option\ccsbcs.c"
N/*------------------------------------------------------------------------*/
N/* Unicode - Local code bidirectional converter  (C)ChaN, 2012            */
N/* (SBCS code pages)                                                      */
N/*------------------------------------------------------------------------*/
N/*  437   U.S. (OEM)
N/   720   Arabic (OEM)
N/   1256  Arabic (Windows)
N/   737   Greek (OEM)
N/   1253  Greek (Windows)
N/   1250  Central Europe (Windows)
N/   775   Baltic (OEM)
N/   1257  Baltic (Windows)
N/   850   Multilingual Latin 1 (OEM)
N/   852   Latin 2 (OEM)
N/   1252  Latin 1 (Windows)
N/   855   Cyrillic (OEM)
N/   1251  Cyrillic (Windows)
N/   866   Russian (OEM)
N/   857   Turkish (OEM)
N/   1254  Turkish (Windows)
N/   858   Multilingual Latin 1 + Euro (OEM)
N/   862   Hebrew (OEM)
N/   1255  Hebrew (Windows)
N/   874   Thai (OEM, Windows)
N/   1258  Vietnam (OEM, Windows)
N*/
N
N#include "../ff.h"
L 1 "..\FATFS\src\option\../ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include file  R0.10a    (C)ChaN, 2014
N/----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following terms.
N/
N/  Copyright (C) 2014, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/
N/----------------------------------------------------------------------------*/
N
N#ifndef _FATFS
N#define _FATFS	29000	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\FATFS\src\option\../integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
S
N#else			/* Embedded platform */
N
N/* This type MUST be 8 bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16 bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 16 bit or 32 bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* These types MUST be 32 bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N#endif
N
N#endif
L 25 "..\FATFS\src\option\../ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\FATFS\src\option\../ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.10a (C)ChaN, 2014
N/---------------------------------------------------------------------------*/
N
N#ifndef _FFCONF
N#define _FFCONF 29000	/* Revision ID */
N
N
N/*---------------------------------------------------------------------------/
N/ Functions and Buffer Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY		0	/* 0:Normal or 1:Tiny */
N/* When _FS_TINY is set to 1, it reduces memory consumption _MAX_SS bytes each
N/  file object. For file data transfer, FatFs uses the common sector buffer in
N/  the file system object (FATFS) instead of private sector buffer eliminated
N/  from the file object (FIL). */
N
N
N#define _FS_READONLY	0	/* 0:Read/Write or 1:Read only */
N/* Setting _FS_READONLY to 1 defines read only configuration. This removes
N/  writing functions, f_write(), f_sync(), f_unlink(), f_mkdir(), f_chmod(),
N/  f_rename(), f_truncate() and useless f_getfree(). */
N
N
N#define _FS_MINIMIZE	0	/* 0 to 3 */
N/* The _FS_MINIMIZE option defines minimization level to remove API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_chmod(), f_utime(),
N/      f_truncate() and f_rename() function are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	1	/* 0:Disable or 1-2:Enable */
N/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
N
N
N#define	_USE_MKFS		1	/* 0:Disable or 1:Enable */
N/* To enable f_mkfs() function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
N
N
N#define	_USE_FASTSEEK	1	/* 0:Disable or 1:Enable */
N/* To enable fast seek feature, set _USE_FASTSEEK to 1. */
N
N
N#define _USE_LABEL		1	/* 0:Disable or 1:Enable */
N/* To enable volume label functions, set _USE_LAVEL to 1 */
N
N
N#define	_USE_FORWARD	0	/* 0:Disable or 1:Enable */
N/* To enable f_forward() function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	437		//采用中文GBK编码
N/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
N/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
N/   949  - Korean (DBCS, OEM, Windows)
N/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
N/   1250 - Central Europe (Windows)
N/   1251 - Cyrillic (Windows)
N/   1252 - Latin 1 (Windows)
N/   1253 - Greek (Windows)
N/   1254 - Turkish (Windows)
N/   1255 - Hebrew (Windows)
N/   1256 - Arabic (Windows)
N/   1257 - Baltic (Windows)
N/   1258 - Vietnam (OEM, Windows)
N/   437  - U.S. (OEM)
N/   720  - Arabic (OEM)
N/   737  - Greek (OEM)
N/   775  - Baltic (OEM)
N/   850  - Multilingual Latin 1 (OEM)
N/   858  - Multilingual Latin 1 + Euro (OEM)
N/   852  - Latin 2 (OEM)
N/   855  - Cyrillic (OEM)
N/   866  - Russian (OEM)
N/   857  - Turkish (OEM)
N/   862  - Hebrew (OEM)
N/   874  - Thai (OEM, Windows)
N/   1    - ASCII (Valid for only non-LFN cfg.) */
N
N
N#define	_USE_LFN	1		/* 0 to 3 设置为1,支持长文件名，并采用动态内存*/
N#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
N/* The _USE_LFN option switches the LFN feature.
N/
N/   0: Disable LFN feature. _MAX_LFN and _LFN_UNICODE have no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  When enable LFN feature, Unicode handling functions ff_convert() and ff_wtoupper()
N/  function must be added to the project.
N/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. When use stack for the
N/  working buffer, take care on stack overflow. When use heap memory for the working
N/  buffer, memory management functions, ff_memalloc() and ff_memfree(), must be added
N/  to the project. */
N
N
N#define	_LFN_UNICODE	0	/* 0:ANSI/OEM or 1:Unicode */
N/* To switch the character encoding on the FatFs API (TCHAR) to Unicode, enable LFN
N/  feature and set _LFN_UNICODE to 1. This option affects behavior of string I/O
N/  functions. */
N
N
N#define _STRF_ENCODE	3	/* 0:ANSI/OEM, 1:UTF-16LE, 2:UTF-16BE, 3:UTF-8 */
N/* When Unicode API is enabled by _LFN_UNICODE option, this option selects the character
N/  encoding on the file to be read/written via string I/O functions, f_gets(), f_putc(),
N/  f_puts and f_printf(). This option has no effect when Unicode API is not enabled. */
N
N
N#define _FS_RPATH		0	/* 0 to 2 */
N/* The _FS_RPATH option configures relative path feature.
N/
N/   0: Disable relative path feature and remove related functions.
N/   1: Enable relative path. f_chdrive() and f_chdir() function are available.
N/   2: f_getcwd() function is available in addition to 1.
N/
N/  Note that output of the f_readdir() fnction is affected by this option. */
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	2
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0	/* 0:Use only 0-9 for drive ID, 1:Use strings for drive ID */
N#define _VOLUME_STRS	"RAM","NAND","CF","SD1","SD2","USB1","USB2","USB3"
N/* When _STR_VOLUME_ID is set to 1, also pre-defined string can be used as drive number
N/  in the path name. _VOLUME_STRS defines the drive ID strings for each logical drives.
N/  Number of items must be equal to _VOLUMES. Valid characters for the drive ID strings
N/  are: 0-9 and A-Z. */
N
N
N#define	_MULTI_PARTITION	0	/* 0:Single partition, 1:Enable multiple partition */
N/* By default(0), each logical drive number is bound to the same physical drive number
N/  and only a FAT volume found on the physical drive is mounted. When it is set to 1,
N/  each logical drive number is bound to arbitrary drive/partition listed in VolToPart[].
N*/
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		512
N/* These options configure the sector size to be supported. (512, 1024, 2048 or 4096)
N/  Always set both 512 for most systems, all memory card and hard disk. But a larger
N/  value may be required for on-board flash memory and some type of optical media.
N/  When _MIN_SS != _MAX_SS, FatFs is configured to multiple sector size and
N/  GET_SECTOR_SIZE command must be implemented to the disk_ioctl() function. */
N
N
N#define	_USE_ERASE	0	/* 0:Disable or 1:Enable */
N/* To enable sector erase feature, set _USE_ERASE to 1. Also CTRL_ERASE_SECTOR command
N/  should be added to the disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0	/* 0 to 3 */
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the last allocated cluster number as bit 0.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define _WORD_ACCESS	0	/* 0 or 1 */
N/* The _WORD_ACCESS option is an only platform dependent option. It defines
N/  which access method is used to the word data on the FAT volume.
N/
N/   0: Byte-by-byte access. Always compatible with all platforms.
N/   1: Word access. Do not choose this unless under both the following conditions.
N/
N/  * Address misaligned memory access is always allowed for all instructions.
N/  * Byte order on the memory is little-endian.
N/
N/  If it is the case, _WORD_ACCESS can also be set to 1 to improve performance
N/  and reduce code size.
N*/
N
N
N#define	_FS_LOCK	0	/* 0:Disable or >=1:Enable */
N/* To enable file lock control feature, set _FS_LOCK to 1 or greater.
N/  The value defines how many files/sub-directories can be opened simultaneously.
N/  This feature consumes _FS_LOCK * 12 bytes of bss area. */
N
N
N#define _FS_REENTRANT	0		/* 0:Disable or 1:Enable */
N#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
N#define	_SYNC_t			HANDLE	/* O/S dependent sync object type. e.g. HANDLE, OS_EVENT*, ID and etc.. */
N/*#include <windows.h>*/
N
N/* A header file that defines sync object types on the O/S, such as windows.h,
N/  ucos_ii.h and semphr.h, should be included here when enable this option.
N/  The _FS_REENTRANT option switches the re-entrancy (thread safe) of the FatFs module.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function must be added to the project.
N*/
N
N
N#endif /* _FFCONFIG */
L 26 "..\FATFS\src\option\../ff.h" 2
N
N#if _FATFS != _FFCONF
X#if 29000 != 29000
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode string */
X#if 0			 
S#if !_USE_LFN
S#error _LFN_UNICODE must be 0 in non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
S
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N
N#endif
N
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
N	BYTE	n_fats;			/* Number of FAT copies (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N#if _MAX_SS != _MIN_SS
X#if 512 != 512
S	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clust;		/* Last allocated cluster */
N	DWORD	free_clust;		/* Number of free clusters */
N#endif
N#if _FS_RPATH
X#if 0
S	DWORD	cdir;			/* Current directory start cluster (0:root) */
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries (= number of clusters + 2) */
N	DWORD	fsize;			/* Sectors per FAT */
N	DWORD	volbase;		/* Volume start sector */
N	DWORD	fatbase;		/* FAT start sector */
N	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
N	DWORD	database;		/* Data start sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[512];	 
N} FATFS;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the related file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	BYTE	flag;			/* File status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	DWORD	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	fsize;			/* File size */
N	DWORD	sclust;			/* File data start cluster (0:no data cluster, always 0 when fsize is 0) */
N	DWORD	clust;			/* Current cluster of fpter */
N	DWORD	dsect;			/* Current data sector of fpter */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the window */
N#endif
N#if _USE_FASTSEEK
X#if 1
N	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */
N#endif
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File data read/write buffer */
X	BYTE	buf[512];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the owner file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	WORD	index;			/* Current read/write index number */
N	DWORD	sclust;			/* Table start cluster (0:Root dir) */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if _USE_LFN
X#if 1
N	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
N	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N} DIR;
N
N
N
N/* File status structure (FILINFO) */
N
Ntypedef struct {
N	DWORD	fsize;			/* File size */
N	WORD	fdate;			/* Last modified date */
N	WORD	ftime;			/* Last modified time */
N	BYTE	fattrib;		/* Attribute */
N	TCHAR	fname[13];		/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 1
N	TCHAR*	lfname;			/* Pointer to the LFN buffer */
N	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from a file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to a file */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_lseek (FIL* fp, DWORD ofs);								/* Move file pointer of a file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of a writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE value, BYTE mask);			/* Change attribute of the file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change times-tamp of the file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* sn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);				/* Create a file system on the volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
N
N#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->fsize)
N
N#ifndef EOF
N#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY
X#if !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN							/* Unicode - OEM code conversion */
X#if 1							 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 1 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Sint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00
N
N#if !_FS_READONLY
X#if !0
N#define	FA_WRITE			0x02
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define FA__WRITTEN			0x20
N#define FA__DIRTY			0x40
N#endif
N
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N
N/* Fast seek feature */
N#define CREATE_LINKMAP	0xFFFFFFFF
N
N
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 29 "..\FATFS\src\option\ccsbcs.c" 2
N
N
N#if _CODE_PAGE == 437
X#if 437 == 437
N#define _TBLDEF 1
Nstatic
Nconst WCHAR Tbl[] = {	/*  CP437(0x80-0xFF) to Unicode conversion table */
N	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
N	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
N	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
N	0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
N	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
N	0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
N	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
N	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
N	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
N	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
N	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
N	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
N	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
N	0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
N	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
N	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
N};
N
N#elif _CODE_PAGE == 720
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP720(0x80-0xFF) to Unicode conversion table */
S	0x0000, 0x0000, 0x00E9, 0x00E2, 0x0000, 0x00E0, 0x0000, 0x00E7,
S	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x0651, 0x0652, 0x00F4, 0x00A4, 0x0640, 0x00FB, 0x00F9,
S	0x0621, 0x0622, 0x0623, 0x0624, 0x00A3, 0x0625, 0x0626, 0x0627,
S	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F,
S	0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
S	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
S	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
S	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
S	0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0x0641, 0x00B5, 0x0642,
S	0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A,
S	0x2261, 0x064B, 0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x2248,
S	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 737
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP737(0x80-0xFF) to Unicode conversion table */
S	0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398,
S	0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0,
S	0x03A1, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9,
S	0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
S	0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0,
S	0x03C1, 0x03C3, 0x03C2, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
S	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
S	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
S	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
S	0x03C9, 0x03AC, 0x03AD, 0x03AE, 0x03CA, 0x03AF, 0x03CC, 0x03CD,
S	0x03CB, 0x03CE, 0x0386, 0x0388, 0x0389, 0x038A, 0x038C, 0x038E,
S	0x038F, 0x00B1, 0x2265, 0x2264, 0x03AA, 0x03AB, 0x00F7, 0x2248,
S	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 775
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP775(0x80-0xFF) to Unicode conversion table */
S	0x0106, 0x00FC, 0x00E9, 0x0101, 0x00E4, 0x0123, 0x00E5, 0x0107,
S	0x0142, 0x0113, 0x0156, 0x0157, 0x012B, 0x0179, 0x00C4, 0x00C5,
S	0x00C9, 0x00E6, 0x00C6, 0x014D, 0x00F6, 0x0122, 0x00A2, 0x015A,
S	0x015B, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x00A4,
S	0x0100, 0x012A, 0x00F3, 0x017B, 0x017C, 0x017A, 0x201D, 0x00A6,
S	0x00A9, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x0141, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0104, 0x010C, 0x0118,
S	0x0116, 0x2563, 0x2551, 0x2557, 0x255D, 0x012E, 0x0160, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0172, 0x016A,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x017D,
S	0x0105, 0x010D, 0x0119, 0x0117, 0x012F, 0x0161, 0x0173, 0x016B,
S	0x017E, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
S	0x00D3, 0x00DF, 0x014C, 0x0143, 0x00F5, 0x00D5, 0x00B5, 0x0144,
S	0x0136, 0x0137, 0x013B, 0x013C, 0x0146, 0x0112, 0x0145, 0x2019,
S	0x00AD, 0x00B1, 0x201C, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x201E,
S	0x00B0, 0x2219, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 850
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP850(0x80-0xFF) to Unicode conversion table */
S	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
S	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
S	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
S	0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
S	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
S	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
S	0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
S	0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x0131, 0x00CD, 0x00CE,
S	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
S	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE,
S	0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
S	0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
S	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 852
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP852(0x80-0xFF) to Unicode conversion table */
S	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x016F, 0x0107, 0x00E7,
S	0x0142, 0x00EB, 0x0150, 0x0151, 0x00EE, 0x0179, 0x00C4, 0x0106,
S	0x00C9, 0x0139, 0x013A, 0x00F4, 0x00F6, 0x013D, 0x013E, 0x015A,
S	0x015B, 0x00D6, 0x00DC, 0x0164, 0x0165, 0x0141, 0x00D7, 0x010D,
S	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x0104, 0x0105, 0x017D, 0x017E,
S	0x0118, 0x0119, 0x00AC, 0x017A, 0x010C, 0x015F, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x011A,
S	0x015E, 0x2563, 0x2551, 0x2557, 0x255D, 0x017B, 0x017C, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0102, 0x0103,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
S	0x0111, 0x0110, 0x010E, 0x00CB, 0x010F, 0x0147, 0x00CD, 0x00CE,
S	0x011B, 0x2518, 0x250C, 0x2588, 0x2584, 0x0162, 0x016E, 0x2580,
S	0x00D3, 0x00DF, 0x00D4, 0x0143, 0x0144, 0x0148, 0x0160, 0x0161,
S	0x0154, 0x00DA, 0x0155, 0x0170, 0x00FD, 0x00DD, 0x0163, 0x00B4,
S	0x00AD, 0x02DD, 0x02DB, 0x02C7, 0x02D8, 0x00A7, 0x00F7, 0x00B8,
S	0x00B0, 0x00A8, 0x02D9, 0x0171, 0x0158, 0x0159, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 855
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP855(0x80-0xFF) to Unicode conversion table */
S	0x0452, 0x0402, 0x0453, 0x0403, 0x0451, 0x0401, 0x0454, 0x0404,
S	0x0455, 0x0405, 0x0456, 0x0406, 0x0457, 0x0407, 0x0458, 0x0408,
S	0x0459, 0x0409, 0x045A, 0x040A, 0x045B, 0x040B, 0x045C, 0x040C,
S	0x045E, 0x040E, 0x045F, 0x040F, 0x044E, 0x042E, 0x044A, 0x042A,
S	0x0430, 0x0410, 0x0431, 0x0411, 0x0446, 0x0426, 0x0434, 0x0414,
S	0x0435, 0x0415, 0x0444, 0x0424, 0x0433, 0x0413, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0445, 0x0425, 0x0438,
S	0x0418, 0x2563, 0x2551, 0x2557, 0x255D, 0x0439, 0x0419, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x043A, 0x041A,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
S	0x043B, 0x041B, 0x043C, 0x041C, 0x043D, 0x041D, 0x043E, 0x041E,
S	0x043F, 0x2518, 0x250C, 0x2588, 0x2584, 0x041F, 0x044F, 0x2580,
S	0x042F, 0x0440, 0x0420, 0x0441, 0x0421, 0x0442, 0x0422, 0x0443,
S	0x0423, 0x0436, 0x0416, 0x0432, 0x0412, 0x044C, 0x042C, 0x2116,
S	0x00AD, 0x044B, 0x042B, 0x0437, 0x0417, 0x0448, 0x0428, 0x044D,
S	0x042D, 0x0449, 0x0429, 0x0447, 0x0427, 0x00A7, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 857
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP857(0x80-0xFF) to Unicode conversion table */
S	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
S	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0131, 0x00C4, 0x00C5,
S	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
S	0x0130, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x015E, 0x015F,
S	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x011E, 0x011F,
S	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
S	0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
S	0x00BA, 0x00AA, 0x00CA, 0x00CB, 0x00C8, 0x0000, 0x00CD, 0x00CE,
S	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
S	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x0000,
S	0x00D7, 0x00DA, 0x00DB, 0x00D9, 0x00EC, 0x00FF, 0x00AF, 0x00B4,
S	0x00AD, 0x00B1, 0x0000, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
S	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 858
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP858(0x80-0xFF) to Unicode conversion table */
S	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
S	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
S	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
S	0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
S	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
S	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
S	0x00A9, 0x2563, 0x2551, 0x2557, 0x2550, 0x00A2, 0x00A5, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
S	0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x20AC, 0x00CD, 0x00CE,
S	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00C6, 0x00CC, 0x2580,
S	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE,
S	0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
S	0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
S	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 862
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP862(0x80-0xFF) to Unicode conversion table */
S	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
S	0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
S	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
S	0x05E8, 0x05E9, 0x05EA, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
S	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
S	0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
S	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
S	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
S	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
S	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
S	0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
S	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
S	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 866
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP866(0x80-0xFF) to Unicode conversion table */
S	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
S	0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
S	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
S	0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
S	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
S	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
S	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
S	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
S	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
S	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
S	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
S	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
S	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
S	0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
S	0x0401, 0x0451, 0x0404, 0x0454, 0x0407, 0x0457, 0x040E, 0x045E,
S	0x00B0, 0x2219, 0x00B7, 0x221A, 0x2116, 0x00A4, 0x25A0, 0x00A0
S};
S
S#elif _CODE_PAGE == 874
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP874(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x2026, 0x0000, 0x0000,
S	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x00A0, 0x0E01, 0x0E02, 0x0E03, 0x0E04, 0x0E05, 0x0E06, 0x0E07,
S	0x0E08, 0x0E09, 0x0E0A, 0x0E0B, 0x0E0C, 0x0E0D, 0x0E0E, 0x0E0F,
S	0x0E10, 0x0E11, 0x0E12, 0x0E13, 0x0E14, 0x0E15, 0x0E16, 0x0E17,
S	0x0E18, 0x0E19, 0x0E1A, 0x0E1B, 0x0E1C, 0x0E1D, 0x0E1E, 0x0E1F,
S	0x0E20, 0x0E21, 0x0E22, 0x0E23, 0x0E24, 0x0E25, 0x0E26, 0x0E27,
S	0x0E28, 0x0E29, 0x0E2A, 0x0E2B, 0x0E2C, 0x0E2D, 0x0E2E, 0x0E2F,
S	0x0E30, 0x0E31, 0x0E32, 0x0E33, 0x0E34, 0x0E35, 0x0E36, 0x0E37,
S	0x0E38, 0x0E39, 0x0E3A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0E3F,
S	0x0E40, 0x0E41, 0x0E42, 0x0E43, 0x0E44, 0x0E45, 0x0E46, 0x0E47,
S	0x0E48, 0x0E49, 0x0E4A, 0x0E4B, 0x0E4C, 0x0E4D, 0x0E4E, 0x0E4F,
S	0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57,
S	0x0E58, 0x0E59, 0x0E5A, 0x0E5B, 0x0000, 0x0000, 0x0000, 0x0000
S};
S
S#elif _CODE_PAGE == 1250
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1250(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x0000, 0x2030, 0x0160, 0x2039, 0x015A, 0x0164, 0x017D, 0x0179,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x0000, 0x2122, 0x0161, 0x203A, 0x015B, 0x0165, 0x017E, 0x017A,
S	0x00A0, 0x02C7, 0x02D8, 0x0141, 0x00A4, 0x0104, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x015E, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x017B,
S	0x00B0, 0x00B1, 0x02DB, 0x0142, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x0105, 0x015F, 0x00BB, 0x013D, 0x02DD, 0x013E, 0x017C,
S	0x0154, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x0139, 0x0106, 0x00C7,
S	0x010C, 0x00C9, 0x0118, 0x00CB, 0x011A, 0x00CD, 0x00CE, 0x010E,
S	0x0110, 0x0143, 0x0147, 0x00D3, 0x00D4, 0x0150, 0x00D6, 0x00D7,
S	0x0158, 0x016E, 0x00DA, 0x0170, 0x00DC, 0x00DD, 0x0162, 0x00DF,
S	0x0155, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x013A, 0x0107, 0x00E7,
S	0x010D, 0x00E9, 0x0119, 0x00EB, 0x011B, 0x00ED, 0x00EE, 0x010F,
S	0x0111, 0x0144, 0x0148, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x00F7,
S	0x0159, 0x016F, 0x00FA, 0x0171, 0x00FC, 0x00FD, 0x0163, 0x02D9
S};
S
S#elif _CODE_PAGE == 1251
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1251(0x80-0xFF) to Unicode conversion table */
S	0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x20AC, 0x2030, 0x0409, 0x2039, 0x040A, 0x040C, 0x040B, 0x040F,
S	0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x0000, 0x2111, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F,
S	0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7,
S	0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
S	0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7,
S	0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457,
S	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
S	0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
S	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
S	0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
S	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
S	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
S	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
S	0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F
S};
S
S#elif _CODE_PAGE == 1252
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1252(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x017D, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x017E, 0x0178,
S	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
S	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
S	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
S	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
S	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
S	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
S	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
S	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
S	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF
S};
S
S#elif _CODE_PAGE == 1253
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1253(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x0000, 0x2030, 0x0000, 0x2039, 0x000C, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x00A0, 0x0385, 0x0386, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x0000, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x2015,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x00B5, 0x00B6, 0x00B7,
S	0x0388, 0x0389, 0x038A, 0x00BB, 0x038C, 0x00BD, 0x038E, 0x038F,
S	0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
S	0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F,
S	0x03A0, 0x03A1, 0x0000, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7,
S	0x03A8, 0x03A9, 0x03AA, 0x03AD, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
S	0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
S	0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
S	0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
S	0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x0000
S};
S
S#elif _CODE_PAGE == 1254
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1254(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x210A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x0000, 0x0178,
S	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
S	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
S	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
S	0x011E, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
S	0x00D8, 0x00D9, 0x00DA, 0x00BD, 0x00DC, 0x0130, 0x015E, 0x00DF,
S	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
S	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
S	0x011F, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
S	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x0131, 0x015F, 0x00FF
S};
S
S#elif _CODE_PAGE == 1255
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1255(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x02C6, 0x2030, 0x0000, 0x2039, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x02DC, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x00F7, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
S	0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7,
S	0x05B8, 0x05B9, 0x0000, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF,
S	0x05C0, 0x05C1, 0x05C2, 0x05C3, 0x05F0, 0x05F1, 0x05F2, 0x05F3,
S	0x05F4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
S	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
S	0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
S	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
S	0x05E8, 0x05E9, 0x05EA, 0x0000, 0x0000, 0x200E, 0x200F, 0x0000
S};
S
S#elif _CODE_PAGE == 1256
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1256(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x067E, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x02C6, 0x2030, 0x0679, 0x2039, 0x0152, 0x0686, 0x0698, 0x0688,
S	0x06AF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x06A9, 0x2122, 0x0691, 0x203A, 0x0153, 0x200C, 0x200D, 0x06BA,
S	0x00A0, 0x060C, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x06BE, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x061B, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x061F,
S	0x06C1, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
S	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F,
S	0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x00D7,
S	0x0637, 0x0638, 0x0639, 0x063A, 0x0640, 0x0640, 0x0642, 0x0643,
S	0x00E0, 0x0644, 0x00E2, 0x0645, 0x0646, 0x0647, 0x0648, 0x00E7,
S	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x0649, 0x064A, 0x00EE, 0x00EF,
S	0x064B, 0x064C, 0x064D, 0x064E, 0x00F4, 0x064F, 0x0650, 0x00F7,
S	0x0651, 0x00F9, 0x0652, 0x00FB, 0x00FC, 0x200E, 0x200F, 0x06D2
S}
S
S#elif _CODE_PAGE == 1257
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1257(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x0000, 0x2030, 0x0000, 0x2039, 0x0000, 0x00A8, 0x02C7, 0x00B8,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x00AF, 0x02DB, 0x0000,
S	0x00A0, 0x0000, 0x00A2, 0x00A3, 0x00A4, 0x0000, 0x00A6, 0x00A7,
S	0x00D8, 0x00A9, 0x0156, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x0157, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00E6,
S	0x0104, 0x012E, 0x0100, 0x0106, 0x00C4, 0x00C5, 0x0118, 0x0112,
S	0x010C, 0x00C9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012A, 0x013B,
S	0x0160, 0x0143, 0x0145, 0x00D3, 0x014C, 0x00D5, 0x00D6, 0x00D7,
S	0x0172, 0x0141, 0x015A, 0x016A, 0x00DC, 0x017B, 0x017D, 0x00DF,
S	0x0105, 0x012F, 0x0101, 0x0107, 0x00E4, 0x00E5, 0x0119, 0x0113,
S	0x010D, 0x00E9, 0x017A, 0x0117, 0x0123, 0x0137, 0x012B, 0x013C,
S	0x0161, 0x0144, 0x0146, 0x00F3, 0x014D, 0x00F5, 0x00F6, 0x00F7,
S	0x0173, 0x014E, 0x015B, 0x016B, 0x00FC, 0x017C, 0x017E, 0x02D9
S};
S
S#elif _CODE_PAGE == 1258
S#define _TBLDEF 1
Sstatic
Sconst WCHAR Tbl[] = {	/*  CP1258(0x80-0xFF) to Unicode conversion table */
S	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
S	0x02C6, 0x2030, 0x0000, 0x2039, 0x0152, 0x0000, 0x0000, 0x0000,
S	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
S	0x02DC, 0x2122, 0x0000, 0x203A, 0x0153, 0x0000, 0x0000, 0x0178,
S	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
S	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
S	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
S	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
S	0x00C0, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
S	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x0300, 0x00CD, 0x00CE, 0x00CF,
S	0x0110, 0x00D1, 0x0309, 0x00D3, 0x00D4, 0x01A0, 0x00D6, 0x00D7,
S	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x01AF, 0x0303, 0x00DF,
S	0x00E0, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
S	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x0301, 0x00ED, 0x00EE, 0x00EF,
S	0x0111, 0x00F1, 0x0323, 0x00F3, 0x00F4, 0x01A1, 0x00F6, 0x00F7,
S	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x01B0, 0x20AB, 0x00FF
S};
S
N#endif
N
N
N#if !_TBLDEF || !_USE_LFN
X#if !1 || !1
S#error This file is not needed in current configuration. Remove from the project.
N#endif
N
N
NWCHAR ff_convert (	/* Converted character, Returns zero on error */
N	WCHAR	chr,	/* Character code to be converted */
N	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
N)
N{
N	WCHAR c;
N
N
N	if (chr < 0x80) {	/* ASCII */
N		c = chr;
N
N	} else {
N		if (dir) {		/* OEMCP to Unicode */
N			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
N
N		} else {		/* Unicode to OEMCP */
N			for (c = 0; c < 0x80; c++) {
N				if (chr == Tbl[c]) break;
N			}
N			c = (c + 0x80) & 0xFF;
N		}
N	}
N
N	return c;
N}
N
N
NWCHAR ff_wtoupper (	/* Upper converted character */
N	WCHAR chr		/* Input character */
N)
N{
N	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
N	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
N	int i;
N
N
N	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
N
N	return tbl_lower[i] ? tbl_upper[i] : chr;
N}
