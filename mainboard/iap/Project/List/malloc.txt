; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\malloc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\malloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\User -I..\User\bsp\inc -I..\User\bsp -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\MALLOC -I..\FATFS\exfuns -I..\FATFS\src -I..\FATFS\src\option -I"E:\Program Files\MDK 4.74\ARM\RV31\INC" -I"E:\Program Files\MDK 4.74\ARM\CMSIS\Include" -I"E:\Program Files\MDK 4.74\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\malloc.crf ..\MALLOC\malloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  mymemcpy PROC
;;;38     //n:需要复制的内存长度(字节为单位)
;;;39     void mymemcpy(void *des,void *src,u32 n)  
000000  b570              PUSH     {r4-r6,lr}
;;;40     {  
;;;41         u8 *xdes=des;
000002  4603              MOV      r3,r0
;;;42     	u8 *xsrc=src; 
000004  460c              MOV      r4,r1
;;;43         while(n--)*xdes++=*xsrc++;  
000006  e003              B        |L1.16|
                  |L1.8|
000008  f8145b01          LDRB     r5,[r4],#1
00000c  f8035b01          STRB     r5,[r3],#1
                  |L1.16|
000010  0015              MOVS     r5,r2
000012  f1a20201          SUB      r2,r2,#1
000016  d1f7              BNE      |L1.8|
;;;44     }  
000018  bd70              POP      {r4-r6,pc}
;;;45     //设置内存
                          ENDP

                  mymemset PROC
;;;48     //count:需要设置的内存大小(字节为单位)
;;;49     void mymemset(void *s,u8 c,u32 count)  
00001a  b530              PUSH     {r4,r5,lr}
;;;50     {  
;;;51         u8 *xs = s;  
00001c  4603              MOV      r3,r0
;;;52         while(count--)*xs++=c;  
00001e  e001              B        |L1.36|
                  |L1.32|
000020  f8031b01          STRB     r1,[r3],#1
                  |L1.36|
000024  0014              MOVS     r4,r2
000026  f1a20201          SUB      r2,r2,#1
00002a  d1f9              BNE      |L1.32|
;;;53     }	   
00002c  bd30              POP      {r4,r5,pc}
;;;54     //内存管理初始化  
                          ENDP

                  mem_init PROC
;;;55     void mem_init(void)  
00002e  b500              PUSH     {lr}
;;;56     {  
;;;57         mymemset(mallco_dev.memmap, 0,memtblsize*2);//内存状态表数据清零  
000030  4957              LDR      r1,|L1.400|
000032  f44f72a0          MOV      r2,#0x140
000036  68c8              LDR      r0,[r1,#0xc]  ; mallco_dev
000038  2100              MOVS     r1,#0
00003a  f7fffffe          BL       mymemset
;;;58     	mymemset(mallco_dev.membase, 0,memsize);	//内存池所有数据清零  
00003e  4954              LDR      r1,|L1.400|
000040  f44f52a0          MOV      r2,#0x1400
000044  6888              LDR      r0,[r1,#8]  ; mallco_dev
000046  2100              MOVS     r1,#0
000048  f7fffffe          BL       mymemset
;;;59     	mallco_dev.memrdy=1;						//内存管理初始化OK  
00004c  2001              MOVS     r0,#1
00004e  4950              LDR      r1,|L1.400|
000050  7408              STRB     r0,[r1,#0x10]
;;;60     }  
000052  bd00              POP      {pc}
;;;61     //获取内存使用率
                          ENDP

                  mem_perused PROC
;;;62     //返回值:使用率(0~100)
;;;63     u8 mem_perused(void)  
000054  2200              MOVS     r2,#0
;;;64     {  
;;;65         u32 used=0;  
;;;66         u32 i;  
;;;67         for(i=0;i<memtblsize;i++)  
000056  2100              MOVS     r1,#0
000058  e006              B        |L1.104|
                  |L1.90|
;;;68         {  
;;;69             if(mallco_dev.memmap[i])used++; 
00005a  484d              LDR      r0,|L1.400|
00005c  68c0              LDR      r0,[r0,#0xc]  ; mallco_dev
00005e  f8300011          LDRH     r0,[r0,r1,LSL #1]
000062  b100              CBZ      r0,|L1.102|
000064  1c52              ADDS     r2,r2,#1
                  |L1.102|
000066  1c49              ADDS     r1,r1,#1              ;67
                  |L1.104|
000068  29a0              CMP      r1,#0xa0              ;67
00006a  d3f6              BCC      |L1.90|
;;;70         } 
;;;71         return (used*100)/(memtblsize);  
00006c  2064              MOVS     r0,#0x64
00006e  4350              MULS     r0,r2,r0
000070  23a0              MOVS     r3,#0xa0
000072  fbb0f0f3          UDIV     r0,r0,r3
000076  b2c0              UXTB     r0,r0
;;;72     }  
000078  4770              BX       lr
;;;73     //内存分配(内部调用)
                          ENDP

                  mem_malloc PROC
;;;76     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;77     u32 mem_malloc(u32 size)  
00007a  e92d41f0          PUSH     {r4-r8,lr}
;;;78     {  
00007e  4606              MOV      r6,r0
;;;79         signed long offset=0;  
000080  2400              MOVS     r4,#0
;;;80         u16 nmemb;	//需要的内存块数  
;;;81     	u16 cmemb=0;//连续空内存块数
000082  46a0              MOV      r8,r4
;;;82         u32 i;  
;;;83         if(!mallco_dev.memrdy)mallco_dev.init();	//未初始化,先执行初始化 
000084  4842              LDR      r0,|L1.400|
000086  7c00              LDRB     r0,[r0,#0x10]  ; mallco_dev
000088  b910              CBNZ     r0,|L1.144|
00008a  4941              LDR      r1,|L1.400|
00008c  6808              LDR      r0,[r1,#0]  ; mallco_dev
00008e  4780              BLX      r0
                  |L1.144|
;;;84         if(size==0)return 0XFFFFFFFF;				//不需要分配
000090  b91e              CBNZ     r6,|L1.154|
000092  f04f30ff          MOV      r0,#0xffffffff
                  |L1.150|
;;;85         nmemb=size/memblksize;  					//获取需要分配的连续内存块数
;;;86         if(size%memblksize)nmemb++;  
;;;87         for(offset=memtblsize-1;offset>=0;offset--)	//搜索整个内存控制区  
;;;88         {     
;;;89     		if(!mallco_dev.memmap[offset])cmemb++;	//连续空内存块数增加
;;;90     		else cmemb=0;							//连续内存块清零
;;;91     		if(cmemb==nmemb)						//找到了连续nmemb个空内存块
;;;92     		{
;;;93                 for(i=0;i<nmemb;i++)  				//标注内存块非空 
;;;94                 {  
;;;95                     mallco_dev.memmap[offset+i]=nmemb;  
;;;96                 }  
;;;97                 return (offset*memblksize);			//返回偏移地址  
;;;98     		}
;;;99         }  
;;;100        return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;101    }  
000096  e8bd81f0          POP      {r4-r8,pc}
                  |L1.154|
00009a  f3c6154f          UBFX     r5,r6,#5,#16          ;85
00009e  f0160f1f          TST      r6,#0x1f              ;86
0000a2  d001              BEQ      |L1.168|
0000a4  1c68              ADDS     r0,r5,#1              ;86
0000a6  b285              UXTH     r5,r0                 ;86
                  |L1.168|
0000a8  249f              MOVS     r4,#0x9f              ;87
0000aa  e01a              B        |L1.226|
                  |L1.172|
0000ac  4838              LDR      r0,|L1.400|
0000ae  68c0              LDR      r0,[r0,#0xc]          ;89  ; mallco_dev
0000b0  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;89
0000b4  b920              CBNZ     r0,|L1.192|
0000b6  f1080001          ADD      r0,r8,#1              ;89
0000ba  fa1ff880          UXTH     r8,r0                 ;89
0000be  e001              B        |L1.196|
                  |L1.192|
0000c0  f04f0800          MOV      r8,#0                 ;90
                  |L1.196|
0000c4  45a8              CMP      r8,r5                 ;91
0000c6  d10b              BNE      |L1.224|
0000c8  2700              MOVS     r7,#0                 ;93
0000ca  e005              B        |L1.216|
                  |L1.204|
0000cc  4830              LDR      r0,|L1.400|
0000ce  68c0              LDR      r0,[r0,#0xc]          ;95  ; mallco_dev
0000d0  19e1              ADDS     r1,r4,r7              ;95
0000d2  f8205011          STRH     r5,[r0,r1,LSL #1]     ;95
0000d6  1c7f              ADDS     r7,r7,#1              ;93
                  |L1.216|
0000d8  42af              CMP      r7,r5                 ;93
0000da  d3f7              BCC      |L1.204|
0000dc  0160              LSLS     r0,r4,#5              ;97
0000de  e7da              B        |L1.150|
                  |L1.224|
0000e0  1e64              SUBS     r4,r4,#1              ;87
                  |L1.226|
0000e2  2c00              CMP      r4,#0                 ;87
0000e4  dae2              BGE      |L1.172|
0000e6  f04f30ff          MOV      r0,#0xffffffff        ;100
0000ea  e7d4              B        |L1.150|
;;;102    //释放内存(内部调用) 
                          ENDP

                  mem_free PROC
;;;104    //返回值:0,释放成功;1,释放失败;  
;;;105    u8 mem_free(u32 offset)  
0000ec  b570              PUSH     {r4-r6,lr}
;;;106    {  
0000ee  4605              MOV      r5,r0
;;;107        int i;  
;;;108        if(!mallco_dev.memrdy)//未初始化,先执行初始化
0000f0  4827              LDR      r0,|L1.400|
0000f2  7c00              LDRB     r0,[r0,#0x10]  ; mallco_dev
0000f4  b920              CBNZ     r0,|L1.256|
;;;109    	{
;;;110    		mallco_dev.init();    
0000f6  4926              LDR      r1,|L1.400|
0000f8  6808              LDR      r0,[r1,#0]  ; mallco_dev
0000fa  4780              BLX      r0
;;;111            return 1;//未初始化  
0000fc  2001              MOVS     r0,#1
                  |L1.254|
;;;112        }  
;;;113        if(offset<memsize)//偏移在内存池内. 
;;;114        {  
;;;115            int index=offset/memblksize;		//偏移所在内存块号码  
;;;116            int nmemb=mallco_dev.memmap[index];	//内存块数量
;;;117            for(i=0;i<nmemb;i++)  				//内存块清零
;;;118            {  
;;;119                mallco_dev.memmap[index+i]=0;  
;;;120            }
;;;121            return 0;  
;;;122        }else return 2;//偏移超区了.  
;;;123    }  
0000fe  bd70              POP      {r4-r6,pc}
                  |L1.256|
000100  f5b55fa0          CMP      r5,#0x1400            ;113
000104  d211              BCS      |L1.298|
000106  0969              LSRS     r1,r5,#5              ;115
000108  4821              LDR      r0,|L1.400|
00010a  68c0              LDR      r0,[r0,#0xc]          ;116  ; mallco_dev
00010c  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;116
000110  2400              MOVS     r4,#0                 ;117
000112  e006              B        |L1.290|
                  |L1.276|
000114  2000              MOVS     r0,#0                 ;119
000116  4b1e              LDR      r3,|L1.400|
000118  68db              LDR      r3,[r3,#0xc]          ;119  ; mallco_dev
00011a  190e              ADDS     r6,r1,r4              ;119
00011c  f8230016          STRH     r0,[r3,r6,LSL #1]     ;119
000120  1c64              ADDS     r4,r4,#1              ;117
                  |L1.290|
000122  4294              CMP      r4,r2                 ;117
000124  dbf6              BLT      |L1.276|
000126  2000              MOVS     r0,#0                 ;121
000128  e7e9              B        |L1.254|
                  |L1.298|
00012a  2002              MOVS     r0,#2                 ;122
00012c  e7e7              B        |L1.254|
;;;124    //释放内存(外部调用) 
                          ENDP

                  myfree PROC
;;;125    //ptr:内存首地址 
;;;126    void myfree(void *ptr)  
00012e  b570              PUSH     {r4-r6,lr}
;;;127    {  
000130  4604              MOV      r4,r0
;;;128    	u32 offset;  
;;;129        if(ptr==NULL)return;//地址为0.  
000132  b904              CBNZ     r4,|L1.310|
                  |L1.308|
;;;130     	offset=(u32)ptr-(u32)mallco_dev.membase;  
;;;131        mem_free(offset);	//释放内存     
;;;132    }  
000134  bd70              POP      {r4-r6,pc}
                  |L1.310|
000136  4816              LDR      r0,|L1.400|
000138  6880              LDR      r0,[r0,#8]            ;130  ; mallco_dev
00013a  1a25              SUBS     r5,r4,r0              ;130
00013c  4628              MOV      r0,r5                 ;131
00013e  f7fffffe          BL       mem_free
000142  bf00              NOP      
000144  e7f6              B        |L1.308|
;;;133    //分配内存(外部调用)
                          ENDP

                  mymalloc PROC
;;;135    //返回值:分配到的内存首地址.
;;;136    void *mymalloc(u32 size)  
000146  b570              PUSH     {r4-r6,lr}
;;;137    {  
000148  4605              MOV      r5,r0
;;;138        u32 offset;  									      
;;;139    	offset=mem_malloc(size);  	   				   
00014a  4628              MOV      r0,r5
00014c  f7fffffe          BL       mem_malloc
000150  4604              MOV      r4,r0
;;;140        if(offset==0XFFFFFFFF)return NULL;  
000152  1c60              ADDS     r0,r4,#1
000154  d100              BNE      |L1.344|
                  |L1.342|
;;;141        else return (void*)((u32)mallco_dev.membase+offset);  
;;;142    }  
000156  bd70              POP      {r4-r6,pc}
                  |L1.344|
000158  480d              LDR      r0,|L1.400|
00015a  6880              LDR      r0,[r0,#8]            ;141  ; mallco_dev
00015c  4420              ADD      r0,r0,r4              ;141
00015e  e7fa              B        |L1.342|
;;;143    //重新分配内存(外部调用)
                          ENDP

                  myrealloc PROC
;;;146    //返回值:新分配到的内存首地址.
;;;147    void *myrealloc(void *ptr,u32 size)  
000160  b570              PUSH     {r4-r6,lr}
;;;148    {  
000162  4606              MOV      r6,r0
000164  460c              MOV      r4,r1
;;;149        u32 offset;  
;;;150        offset=mem_malloc(size);  
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       mem_malloc
00016c  4605              MOV      r5,r0
;;;151        if(offset==0XFFFFFFFF)return NULL;     
00016e  1c68              ADDS     r0,r5,#1
000170  d100              BNE      |L1.372|
                  |L1.370|
;;;152        else  
;;;153        {  									   
;;;154    	    mymemcpy((void*)((u32)mallco_dev.membase+offset),ptr,size);	//拷贝旧内存内容到新内存   
;;;155            myfree(ptr);  											  	//释放旧内存
;;;156            return (void*)((u32)mallco_dev.membase+offset);  			//返回新内存首地址
;;;157        }  
;;;158    }
000172  bd70              POP      {r4-r6,pc}
                  |L1.372|
000174  4906              LDR      r1,|L1.400|
000176  6889              LDR      r1,[r1,#8]            ;154  ; mallco_dev
000178  1948              ADDS     r0,r1,r5              ;154
00017a  4622              MOV      r2,r4                 ;154
00017c  4631              MOV      r1,r6                 ;154
00017e  f7fffffe          BL       mymemcpy
000182  4630              MOV      r0,r6                 ;155
000184  f7fffffe          BL       myfree
000188  4801              LDR      r0,|L1.400|
00018a  6880              LDR      r0,[r0,#8]            ;156  ; mallco_dev
00018c  4428              ADD      r0,r0,r5              ;156
00018e  e7f0              B        |L1.370|
;;;159    
                          ENDP

                  |L1.400|
                          DCD      mallco_dev

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  membase
                          %        5120
                  memmapbase
                          %        320

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x000000a0
                  memblksize
                          DCD      0x00000020
                  memsize
                          DCD      0x00001400

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      mem_init
                          DCD      mem_perused
                          DCD      membase
                          DCD      memmapbase
000010  00000000          DCB      0x00,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\MALLOC\\malloc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_malloc_c_4dd4ad64____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_malloc_c_4dd4ad64____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_malloc_c_4dd4ad64____REVSH|
#line 128
|__asm___8_malloc_c_4dd4ad64____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
